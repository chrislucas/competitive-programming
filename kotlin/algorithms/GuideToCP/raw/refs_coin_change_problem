/**
 * Esboco da arvore de recursao para o problema

    para funcao recurso FN(S, V) -> S = (1,3,4) V = 6

 *
 * Definimos um valor muito alto como INFINITO para compararmos com a solucao encontrada
 * pelo algoritmo recursivo
 *

 * INF = (1 << 31) - 1
 *
 * se (v == 0) return  0
 * se (v < 0) return  INF
 *
 * m = INF
 * para s in S -> s = 1, V = 5 -> fn(5 - 1)
 * para s in S -> s = 1, V = 4 -> fn(4 - 1)
 * para s in S -> s = 1, V = 3 -> fn(3 - 1)
 * para s in S -> s = 1, V = 2 -> fn(2 - 1)
 * para s in S -> s = 1, V = 1 -> fn(1 - 1)
 *

    fn(V - s)

    para s in S -> s = 1, V = 0, return p = fn(0) + 1, p = 1
    m = min(m,p) -> m = 1, V = 1

    para s in S -> s = 3, V = 1 -> fn(1 - 3) = return p = fn(-2) + 1, p = INF + 1
    m = min(m = 1, p =  INF + 1) -> m = 1, V = 1

    para s in S -> s = 4, V = 1 -> fn(1 - 4) = return p = fn(-3) + 1, p = INF + 1
    m = min(m = 1, p =  INF + 1) -> m = 1, V = 1

    fim do loop
    Para instancia do problema S = (1, 3, 4); V = 1
    m = 1 (1 moeda e 1)
    ------------------------------------------------------------------------------------------------------------------
    Para instancia do problema S = (1, 3, 4); V = 2, m = INF

    para s in S -> s = 1, V = 2 -> fn(2 - 1) = return p = fn(1) + 1, p = 2
    m = min(m = INF, p = 2) -> m = 2, V = 2

    para s in S -> s = 3, V = 2 -> fn(2 - 3) = return p = fn(-1) + 1, p = INF + 1
    m = min(m = 1, p = INF) -> m = 2, V = 2

    para s in S -> s = 4, V = 2 -> fn(2 - 4) = return p = fn(-2) + 1, p = INF + 1
    m = min(m = 1, p = INF) -> m = 2, V = 2

    fim loop
    Para instancia do problema S = (1, 3, 4); V = 2, m = INF
    min = 2 (2 moedas de 1)
    ------------------------------------------------------------------------------------------------------------------
    Para instancia do problema S = (1, 3, 4); V = 3, m = INF

    para s in S -> s = 1, V = 3 -> fn(3 - 1) = return p = fn(2) + 1, p = 3
    m = min(m = INF, p = 3) -> m = 3, V = 3

    para s in S -> s = 3, V = 3 -> fn(3 - 3) = return p = fn(0) + 1, p = 1
    m = min(m = 3, p = 3) -> m = 1, V = 3

    para s in S -> s = 4, V = 3 -> fn(3 - 4) = return p = fn(-1) + 1, p = INF
    m = min(m = 1, p = INF) -> m = 1, V = 3

    fim loop
    Para instancia do problema S = (1, 3, 4); V = 3, m = INF
    min = 1 (1 moeda de 3)
    ------------------------------------------------------------------------------------------------------------------
    Para instancia do problema S = (1, 3, 4); V = 4, m = INF

    para s in S -> s = 1, V = 4 -> fn(4 - 1) = return p = fn(3) + 1, p = 2
    m = min(m = INF, p = 2) -> m = 2, V = 4

    para s in S -> s = 3, V = 4 -> fn(4 - 3) = return p = fn(1) + 1, p = ?
    m = min(m = 2, p = ?) -> m = 2, V = 4

        para s in S -> s = 1, V = 1 -> fn(1 - 1) = return p = fn(1) + 1, p = 1
        m = min(m = 2, p = 1) -> m = 1, V = 1

        para s in S -> s = 3, V = 1 -> fn(1 - 3) = return p = fn(-2) + 1, p = INF
        m = min(m = 1, p = INF) -> m = 1, V = 1

        para s in S -> s = 4, V = 1 -> fn(1 - 4) = return p = fn(-3) + 1, p = INF
        m = min(m = 1, p = INF) -> m = 1, V = 1

       fim loop
       Para instancia do problema S = (1, 3, 4); V = 1, m = INF
       min = 1
       (Por isso que para instancia S = (1, 3 , 4); s = 3; V = 4 fn(4 - 1 = 1) + 1 = 2, a instancia do subproblema resultou em
       min = 1)

    para s in S -> s = 3, V = 4 -> fn(4 - 3) = return p = fn(1) + 1, p = 2 (p = 2 eh explicado no loop acima)
    m = min(m = 2, p = 2) -> m = 2, V = 4

    para s in S -> s = 4, V = 4 -> fn(4 - 4) = return p = fn(0) + 1, p = 1
    m = min(m = 2, p = 1) -> m = 1, V = 4

    fim loop
    Para instancia do problema S = (1, 3, 4); V = 4, m = INF
    min = 1 (1 moeada de 4)
    ------------------------------------------------------------------------------------------------------------------
    Para instancia do problema S = (1, 3, 4); V = 5, m = INF

    para s in S -> s = 1, V = 5 -> fn(5 - 1) = return p = fn(4) + 1, p = 2 (acima vemos que f(4) = 1)
    m = min(m = INF, p = 2) -> m = 2, V = 5

    para s in S -> s = 3, V = 5 -> fn(5 - 3) = return p = fn(2) + 1, p = ?
        para s in S -> s = 1, V = 2 -> fn(2 - 1) = return p = fn(1) + 1, p = ?
            para s in S -> s = 1, V = 1 -> fn(1 - 1) = return p = fn(0) + 1, p = 1
                m = min(m = INF, p = 2) -> m = 1, V = 1

            para s in S -> s = 3, V = 1 -> fn(1 - 3) = return p = fn(-2) + 1, p = INF
            m = min(m = 1, p = INF) -> m = 1, V = 1

            para s in S -> s = 4, V = 1 -> fn(1 - 4) = return p = fn(-3) + 1, p = INF
            m = min(m = 1, p = INF) -> m = 1, V = 1

            fim loop
            Para instancia do problema S = (1, 3, 4); V = 1, m = INF
            min = 1 (1 moeada de 4)

        para s in S -> s = 1, V = 2 -> fn(2 - 1) = return p = fn(1) + 1, p = 2 (acima vimos que f(1) = 1)
        m = min(m = INF, p = 2) -> m = 2, V = 2

        para s in S -> s = 3, V = 2 -> fn(2 - 3) = return p = fn(-1) + 1, p = INF
        m = min(m = 2, p = INF) -> m = 2, V = 2

        para s in S -> s = 4, V = 2 -> fn(2 - 4) = return p = fn(-2) + 1, p = INF
        m = min(m = 2, p = INF) -> m = 2, V = 2

        fim loop
        Para instancia do problema S = (1, 3, 4); V = 2, m = INF
        min = 2 (2 moeada de 1)

    para s in S -> s = 3, V = 5 -> fn(5 - 3) = return p = fn(2) + 1, p = 3 (vimos acima que f(2) = 2)
    m = min(m = 2, p = 3) -> m = 2, V = 2

    para s in S -> s = 4, V = 5 -> fn(5 - 4) = return p = fn(1) + 1, p = 2 (vimos acima que f(1) = 1)
        para s in S -> s = 1, V = 1 -> fn(1 - 1) = return p = fn(0) + 1, p = 1 (vimos acima que f(0) = 0)
        m = min(m = INF, p = 1) -> m = 1, V = 1

        para s in S -> s = 3, V = 1 -> fn(1 - 3) = return p = fn(-2) + 1, p = INF
        m = min(m = 1, p = INF) -> m = 1, V = 1

        para s in S -> s = 4, V = 1 -> fn(1 - 4) = return p = fn(-3) + 1, p = INF
        m = min(m = 1, p = INF) -> m = 1, V = 1

        fim loop
        Para instancia do problema S = (1, 3, 4); V = 1, m = 1
        min = 1
    para s in S -> s = 4, V = 5 -> fn(5 - 4) = return p = fn(1) + 1, p = 2 (vimos acima que f(1) = 1)
    m = min(m = 2, p = 2) -> m = 2, V = 2

    fim loop
    Para instancia do problema S = (1, 3, 4); V = 4, m = INF
    min = 2 (1, 3 = 4)


// matriz para resolver usando com programacao dinamica

instancia do problema S =(1,3,4); V = 6
linha  -> valores de 1 a V. Resolvemos os subproblemas 1. 2, 3 ... para chegar na solucao de valor V
coluna -> valores de moedas a disponiveis para resolver o problema
s 1 3 4 ->
0 0 0 0
1 1 INF INF
2 2 INF INF
3 3 1 INF
4 4 2 1
5 5 3 4
6 6 2 4

memo[i][j] = memo[i][j] + min(memo[i-1][j] + 1, s[j])


// MIN Coin change
https://riptutorial.com/dynamic-programming/example/25891/minimum-number-of-coins-to-get-total
https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/

